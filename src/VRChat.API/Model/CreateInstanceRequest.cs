/*
 * VRChat API Documentation
 *
 *
 * The version of the OpenAPI document: 1.18.4
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = VRChat.API.Client.OpenAPIDateConverter;

namespace VRChat.API.Model
{
    /// <summary>
    /// CreateInstanceRequest
    /// </summary>
    [DataContract(Name = "CreateInstanceRequest")]
    public partial class CreateInstanceRequest : IEquatable<CreateInstanceRequest>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type", IsRequired = true, EmitDefaultValue = true)]
        public InstanceType Type { get; set; }

        /// <summary>
        /// Gets or Sets Region
        /// </summary>
        [DataMember(Name = "region", IsRequired = true, EmitDefaultValue = true)]
        public InstanceRegion Region { get; set; }

        /// <summary>
        /// Gets or Sets GroupAccessType
        /// </summary>
        [DataMember(Name = "groupAccessType", EmitDefaultValue = false)]
        public GroupAccessType? GroupAccessType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateInstanceRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CreateInstanceRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateInstanceRequest" /> class.
        /// </summary>
        /// <param name="worldId">WorldID be \&quot;offline\&quot; on User profiles if you are not friends with that user. (required).</param>
        /// <param name="type">type (required).</param>
        /// <param name="region">region (required).</param>
        /// <param name="ownerId">A groupId if the instance type is \&quot;group\&quot;, null if instance type is public, or a userId otherwise.</param>
        /// <param name="roleIds">Group roleIds that are allowed to join if the type is \&quot;group\&quot; and groupAccessType is \&quot;member\&quot;.</param>
        /// <param name="groupAccessType">groupAccessType.</param>
        /// <param name="queueEnabled">queueEnabled (default to false).</param>
        /// <param name="closedAt">The time after which users won&#39;t be allowed to join the instance. This doesn&#39;t work for public instances..</param>
        /// <param name="canRequestInvite">Only applies to invite type instances to make them invite+ (default to false).</param>
        /// <param name="hardClose">Currently unused, but will eventually be a flag to set if the closing of the instance should kick people. (default to false).</param>
        /// <param name="inviteOnly">inviteOnly (default to false).</param>
        public CreateInstanceRequest(string worldId = default(string), InstanceType type = default(InstanceType), InstanceRegion region = default(InstanceRegion), string ownerId = default(string), List<string> roleIds = default(List<string>), GroupAccessType? groupAccessType = default(GroupAccessType?), bool queueEnabled = false, DateTime closedAt = default(DateTime), bool canRequestInvite = false, bool hardClose = false, bool inviteOnly = false)
        {
            // to ensure "worldId" is required (not null)
            if (worldId == null)
            {
                throw new ArgumentNullException("worldId is a required property for CreateInstanceRequest and cannot be null");
            }
            this.WorldId = worldId;
            this.Type = type;
            this.Region = region;
            this.OwnerId = ownerId;
            this.RoleIds = roleIds;
            this.GroupAccessType = groupAccessType;
            this.QueueEnabled = queueEnabled;
            this.ClosedAt = closedAt;
            this.CanRequestInvite = canRequestInvite;
            this.HardClose = hardClose;
            this.InviteOnly = inviteOnly;
        }

        /// <summary>
        /// WorldID be \&quot;offline\&quot; on User profiles if you are not friends with that user.
        /// </summary>
        /// <value>WorldID be \&quot;offline\&quot; on User profiles if you are not friends with that user.</value>
        [DataMember(Name = "worldId", IsRequired = true, EmitDefaultValue = true)]
        public string WorldId { get; set; }

        /// <summary>
        /// A groupId if the instance type is \&quot;group\&quot;, null if instance type is public, or a userId otherwise
        /// </summary>
        /// <value>A groupId if the instance type is \&quot;group\&quot;, null if instance type is public, or a userId otherwise</value>
        [DataMember(Name = "ownerId", EmitDefaultValue = true)]
        public string OwnerId { get; set; }

        /// <summary>
        /// Group roleIds that are allowed to join if the type is \&quot;group\&quot; and groupAccessType is \&quot;member\&quot;
        /// </summary>
        /// <value>Group roleIds that are allowed to join if the type is \&quot;group\&quot; and groupAccessType is \&quot;member\&quot;</value>
        [DataMember(Name = "roleIds", EmitDefaultValue = false)]
        public List<string> RoleIds { get; set; }

        /// <summary>
        /// Gets or Sets QueueEnabled
        /// </summary>
        [DataMember(Name = "queueEnabled", EmitDefaultValue = true)]
        public bool QueueEnabled { get; set; }

        /// <summary>
        /// The time after which users won&#39;t be allowed to join the instance. This doesn&#39;t work for public instances.
        /// </summary>
        /// <value>The time after which users won&#39;t be allowed to join the instance. This doesn&#39;t work for public instances.</value>
        [DataMember(Name = "closedAt", EmitDefaultValue = false)]
        public DateTime ClosedAt { get; set; }

        /// <summary>
        /// Only applies to invite type instances to make them invite+
        /// </summary>
        /// <value>Only applies to invite type instances to make them invite+</value>
        [DataMember(Name = "canRequestInvite", EmitDefaultValue = true)]
        public bool CanRequestInvite { get; set; }

        /// <summary>
        /// Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.
        /// </summary>
        /// <value>Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.</value>
        [DataMember(Name = "hardClose", EmitDefaultValue = true)]
        public bool HardClose { get; set; }

        /// <summary>
        /// Gets or Sets InviteOnly
        /// </summary>
        [DataMember(Name = "inviteOnly", EmitDefaultValue = true)]
        public bool InviteOnly { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CreateInstanceRequest {\n");
            sb.Append("  WorldId: ").Append(WorldId).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Region: ").Append(Region).Append("\n");
            sb.Append("  OwnerId: ").Append(OwnerId).Append("\n");
            sb.Append("  RoleIds: ").Append(RoleIds).Append("\n");
            sb.Append("  GroupAccessType: ").Append(GroupAccessType).Append("\n");
            sb.Append("  QueueEnabled: ").Append(QueueEnabled).Append("\n");
            sb.Append("  ClosedAt: ").Append(ClosedAt).Append("\n");
            sb.Append("  CanRequestInvite: ").Append(CanRequestInvite).Append("\n");
            sb.Append("  HardClose: ").Append(HardClose).Append("\n");
            sb.Append("  InviteOnly: ").Append(InviteOnly).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CreateInstanceRequest);
        }

        /// <summary>
        /// Returns true if CreateInstanceRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of CreateInstanceRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreateInstanceRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.WorldId == input.WorldId ||
                    (this.WorldId != null &&
                    this.WorldId.Equals(input.WorldId))
                ) && 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.Region == input.Region ||
                    this.Region.Equals(input.Region)
                ) && 
                (
                    this.OwnerId == input.OwnerId ||
                    (this.OwnerId != null &&
                    this.OwnerId.Equals(input.OwnerId))
                ) && 
                (
                    this.RoleIds == input.RoleIds ||
                    this.RoleIds != null &&
                    input.RoleIds != null &&
                    this.RoleIds.SequenceEqual(input.RoleIds)
                ) && 
                (
                    this.GroupAccessType == input.GroupAccessType ||
                    this.GroupAccessType.Equals(input.GroupAccessType)
                ) && 
                (
                    this.QueueEnabled == input.QueueEnabled ||
                    this.QueueEnabled.Equals(input.QueueEnabled)
                ) && 
                (
                    this.ClosedAt == input.ClosedAt ||
                    (this.ClosedAt != null &&
                    this.ClosedAt.Equals(input.ClosedAt))
                ) && 
                (
                    this.CanRequestInvite == input.CanRequestInvite ||
                    this.CanRequestInvite.Equals(input.CanRequestInvite)
                ) && 
                (
                    this.HardClose == input.HardClose ||
                    this.HardClose.Equals(input.HardClose)
                ) && 
                (
                    this.InviteOnly == input.InviteOnly ||
                    this.InviteOnly.Equals(input.InviteOnly)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.WorldId != null)
                {
                    hashCode = (hashCode * 59) + this.WorldId.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Type.GetHashCode();
                hashCode = (hashCode * 59) + this.Region.GetHashCode();
                if (this.OwnerId != null)
                {
                    hashCode = (hashCode * 59) + this.OwnerId.GetHashCode();
                }
                if (this.RoleIds != null)
                {
                    hashCode = (hashCode * 59) + this.RoleIds.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.GroupAccessType.GetHashCode();
                hashCode = (hashCode * 59) + this.QueueEnabled.GetHashCode();
                if (this.ClosedAt != null)
                {
                    hashCode = (hashCode * 59) + this.ClosedAt.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.CanRequestInvite.GetHashCode();
                hashCode = (hashCode * 59) + this.HardClose.GetHashCode();
                hashCode = (hashCode * 59) + this.InviteOnly.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
