using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using VRChat.API.Realtime.Models;
using VRChat.API.Realtime.Messages;

namespace VRChat.API.Realtime
{
    /// <summary>
    /// A generic interface for communicating with VRChat's Realtime WebSocket API (Pipeline).
    /// </summary>
    public interface IVRChatRealtime : IDisposable
    {
        #region Connection Events

        /// <summary>
        /// Raised when a log message is generated by the client.
        /// </summary>
        event EventHandler<LogEventArgs> Log;

        /// <summary>
        /// Raised when the WebSocket connection is disconnected.
        /// </summary>
        event EventHandler OnDisconnected;

        /// <summary>
        /// Raised when the WebSocket connection is successfully established.
        /// </summary>
        event EventHandler OnConnected;

        /// <summary>
        /// Raised when the client is attempting to auto-reconnect to the WebSocket.
        /// </summary>
        event EventHandler OnAutoReconnecting;

        /// <summary>
        /// Raised when any raw message is received from the WebSocket.
        /// </summary>
        event EventHandler<VRChatEventArgs<string>> OnMessageReceived;

        /// <summary>
        /// Raised when a heartbeat message is sent to the server.
        /// </summary>
        event EventHandler OnHeartbeat;

        /// <summary>
        /// Raised when any parsed event is received from the WebSocket.
        /// </summary>
        event EventHandler<VRChatEventArgs<object>> OnEvent;

        #endregion 

        #region Notification Events

        /// <summary>
        /// <b>[Legacy]</b> Raised when a notification is received. <br/>
        /// Use <see cref="OnNotificationReceived"/> instead for consistency.
        /// </summary>
        event EventHandler<VRChatEventArgs<Notification>> OnNotification;

        /// <summary>
        /// Raised when a notification is received from VRChat. <br/>
        /// This includes friend requests, invites, and other in-game notifications.
        /// </summary>
        event EventHandler<VRChatEventArgs<Notification>> OnNotificationReceived;

        /// <summary>
        /// Raised when a response to a previously sent notification is received.
        /// </summary>
        event EventHandler<VRChatEventArgs<ResponseNotificationContent>> OnResponseNotification;

        /// <summary>
        /// Raised when the client should mark a specific notification as seen.
        /// </summary>
        event EventHandler<VRChatEventArgs<string>> OnSeeNotification;

        /// <summary>
        /// Raised when the client should hide a specific notification.
        /// </summary>
        event EventHandler<VRChatEventArgs<string>> OnHideNotification;

        /// <summary>
        /// Raised when the client should clear all notifications.
        /// </summary>
        event EventHandler OnClearNotification;

        /// <summary>
        /// Raised when a V2 notification is received from VRChat. <br/>
        /// V2 notifications include group announcements and other system messages.
        /// </summary>
        event EventHandler<VRChatEventArgs<NotificationV2Content>> OnNotificationV2;

        /// <summary>
        /// Raised when a V2 notification should be updated with new properties.
        /// </summary>
        event EventHandler<VRChatEventArgs<NotificationV2UpdateContent>> OnNotificationV2Update;

        /// <summary>
        /// Raised when one or more V2 notifications should be deleted.
        /// </summary>
        event EventHandler<VRChatEventArgs<NotificationV2DeleteContent>> OnNotificationV2Delete;

        #endregion

        #region Friend Events

        /// <summary>
        /// Raised when a friend is added or a friend request is accepted.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendAddContent>> OnFriendAdd;

        /// <summary>
        /// Raised when a friend is removed or unfriended.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendDeleteContent>> OnFriendDelete;

        /// <summary>
        /// Raised when a friend comes online in VRChat.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendOnlineContent>> OnFriendOnline;

        /// <summary>
        /// Raised when a friend becomes active on the VRChat website.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendActiveContent>> OnFriendActive;

        /// <summary>
        /// Raised when a friend goes offline.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendOfflineContent>> OnFriendOffline;

        /// <summary>
        /// Raised when a friend's profile information is updated.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendUpdateContent>> OnFriendUpdate;

        /// <summary>
        /// Raised when a friend changes their location or instance.
        /// </summary>
        event EventHandler<VRChatEventArgs<FriendLocationContent>> OnFriendLocation;

        #endregion

        #region User Events

        /// <summary>
        /// Raised when the current user's profile information is updated.
        /// </summary>
        event EventHandler<VRChatEventArgs<UserUpdateContent>> OnUserUpdate;

        /// <summary>
        /// Raised when the current user changes their location or instance.
        /// </summary>
        event EventHandler<VRChatEventArgs<UserLocationContent>> OnUserLocation;

        /// <summary>
        /// Raised when the current user is assigned a badge (e.g., VRChat+ subscription).
        /// </summary>
        event EventHandler<VRChatEventArgs<UserBadgeAssignedContent>> OnUserBadgeAssigned;

        /// <summary>
        /// Raised when the current user loses a badge (e.g., VRChat+ subscription expires).
        /// </summary>
        event EventHandler<VRChatEventArgs<UserBadgeUnassignedContent>> OnUserBadgeUnassigned;

        /// <summary>
        /// Raised when content is added or removed from the user's profile. <br/>
        /// This includes avatars, worlds, images, and other user-uploaded content.
        /// </summary>
        event EventHandler<VRChatEventArgs<ContentRefreshContent>> OnContentRefresh;

        /// <summary>
        /// Raised when an image file is modified or updated.
        /// </summary>
        event EventHandler<VRChatEventArgs<ModifiedImageUpdateContent>> OnModifiedImageUpdate;

        /// <summary>
        /// Raised when the user joins a queue to enter an instance.
        /// </summary>
        event EventHandler<VRChatEventArgs<InstanceQueueJoinedContent>> OnInstanceQueueJoined;

        /// <summary>
        /// Raised when the user reaches the front of the instance queue and can join.
        /// </summary>
        event EventHandler<VRChatEventArgs<InstanceQueueReadyContent>> OnInstanceQueueReady;

        #endregion

        #region Group Events

        /// <summary>
        /// Raised when the user joins a group or has a group join request accepted.
        /// </summary>
        event EventHandler<VRChatEventArgs<GroupJoinedContent>> OnGroupJoined;

        /// <summary>
        /// Raised when the user leaves a group or is removed from a group.
        /// </summary>
        event EventHandler<VRChatEventArgs<GroupLeftContent>> OnGroupLeft;

        /// <summary>
        /// Raised when the user's group membership information is updated.
        /// </summary>
        event EventHandler<VRChatEventArgs<GroupMemberUpdatedContent>> OnGroupMemberUpdated;

        /// <summary>
        /// Raised when a group role is updated or modified.
        /// </summary>
        event EventHandler<VRChatEventArgs<GroupRoleUpdatedContent>> OnGroupRoleUpdated;

        #endregion

        #region Methods

        /// <summary>
        /// Connects to the VRChat WebSocket API (Pipeline) asynchronously.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token for cancelling the connection operation.</param>
        /// <returns>A <see cref="Task"/> representing the asynchronous connection operation.</returns>
        Task ConnectAsync(CancellationToken cancellationToken = default);

        /// <summary>
        /// Disconnects from the VRChat WebSocket API asynchronously.
        /// </summary>
        /// <returns>A <see cref="Task"/> representing the asynchronous disconnection operation.</returns>
        Task DisconnectAsync();

        /// <summary>
        /// Gets a value indicating whether the client is currently connected to the WebSocket.
        /// </summary>
        bool IsConnected { get; }

        /// <summary>
        /// Releases all resources used by the VRChat realtime client.
        /// </summary>
        /// <remarks>
        /// This method is inherited from <see cref="IDisposable"/>.
        /// </remarks>
        new void Dispose();

        #endregion
    }

    /// <summary>
    /// Implementation of <see cref="IVRChatRealtime"/> that provides realtime communication
    /// with VRChat's Pipeline WebSocket API.
    /// </summary>
    /// <remarks>
    /// Use <see cref="VRChatRealtimeClientBuilder"/> to create and configure instances of this class.
    /// </remarks>
    /// <seealso cref="IVRChatRealtime"/>
    /// <seealso cref="VRChatRealtimeClientBuilder"/>
    public partial class VRChatRealtimeClient : IVRChatRealtime, IDisposable
    {
        private readonly VRChatRealtimeConfiguration _configuration;
        private ClientWebSocket _client;
        private Timer _reconnectTimer;
        private Timer _heartbeatTimer;
        private CancellationTokenSource _receiveCts;
        private Task _receiveTask;
        private bool _isManualDisconnect;
        private bool _disposed;
        private readonly SemaphoreSlim _sendLock = new SemaphoreSlim(1, 1);

        #region Connection Events

        /// <inheritdoc/>
        public event EventHandler<LogEventArgs> Log;

        /// <inheritdoc/>
        public event EventHandler OnDisconnected;

        /// <inheritdoc/>
        public event EventHandler OnConnected;

        /// <inheritdoc/>
        public event EventHandler OnAutoReconnecting;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<string>> OnMessageReceived;

        /// <inheritdoc/>
        public event EventHandler OnHeartbeat;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<object>> OnEvent;

        #endregion

        #region Notification Events

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<Notification>> OnNotification;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<Notification>> OnNotificationReceived;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<ResponseNotificationContent>> OnResponseNotification;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<string>> OnSeeNotification;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<string>> OnHideNotification;

        /// <inheritdoc/>
        public event EventHandler OnClearNotification;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<NotificationV2Content>> OnNotificationV2;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<NotificationV2UpdateContent>> OnNotificationV2Update;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<NotificationV2DeleteContent>> OnNotificationV2Delete;

        #endregion

        #region Friend Events

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendAddContent>> OnFriendAdd;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendDeleteContent>> OnFriendDelete;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendOnlineContent>> OnFriendOnline;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendActiveContent>> OnFriendActive;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendOfflineContent>> OnFriendOffline;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendUpdateContent>> OnFriendUpdate;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<FriendLocationContent>> OnFriendLocation;

        #endregion

        #region User Events

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<UserUpdateContent>> OnUserUpdate;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<UserLocationContent>> OnUserLocation;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<UserBadgeAssignedContent>> OnUserBadgeAssigned;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<UserBadgeUnassignedContent>> OnUserBadgeUnassigned;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<ContentRefreshContent>> OnContentRefresh;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<ModifiedImageUpdateContent>> OnModifiedImageUpdate;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<InstanceQueueJoinedContent>> OnInstanceQueueJoined;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<InstanceQueueReadyContent>> OnInstanceQueueReady;

        #endregion

        #region Group Events

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<GroupJoinedContent>> OnGroupJoined;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<GroupLeftContent>> OnGroupLeft;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<GroupMemberUpdatedContent>> OnGroupMemberUpdated;

        /// <inheritdoc/>
        public event EventHandler<VRChatEventArgs<GroupRoleUpdatedContent>> OnGroupRoleUpdated;

        #endregion

        /// <inheritdoc/>
        public bool IsConnected => _client?.State == WebSocketState.Open;

        /// <summary>
        /// Initializes a new instance of the <see cref="VRChatRealtimeClient"/> class.
        /// </summary>
        /// <param name="configuration">The configuration settings for the client.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="configuration"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException">Thrown if <see cref="VRChatRealtimeConfiguration.AuthToken"/> is not set.</exception>
        /// <remarks>
        /// Use <see cref="VRChatRealtimeClientBuilder"/> for a more convenient way to create and configure the client.
        /// </remarks>
        public VRChatRealtimeClient(VRChatRealtimeConfiguration configuration)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            
            if (string.IsNullOrWhiteSpace(_configuration.AuthToken))
                throw new ArgumentException("AuthToken is required", nameof(configuration));
        }

        /// <inheritdoc/>
        public async Task ConnectAsync(CancellationToken cancellationToken = default)
        {
            if (_client?.State == WebSocketState.Open)
            {
                LogMessage(LogLevel.Warning, "Already connected to VRChat WebSocket");
                return;
            }

            try
            {
                _isManualDisconnect = false;
                _receiveCts?.Cancel();
                _receiveCts?.Dispose();
                _receiveCts = new CancellationTokenSource();

                var url = $"{_configuration.EndpointURL.TrimEnd('/')}/?authToken={_configuration.AuthToken}";
                
                _client?.Dispose();
                _client = new ClientWebSocket();
                
                if (!string.IsNullOrWhiteSpace(_configuration.UserAgent))
                {
                    _client.Options.SetRequestHeader("User-Agent", _configuration.UserAgent);
                }

                await _client.ConnectAsync(new Uri(url), cancellationToken);

                LogMessage(LogLevel.Info, "Connected to VRChat WebSocket");
                OnConnected?.Invoke(this, EventArgs.Empty);

                // Start receiving messages
                _receiveTask = ReceiveLoop(_receiveCts.Token);

                // Setup periodic reconnect timer
                SetupReconnectTimer();

                // Setup heartbeat timer (every 30 seconds)
                SetupHeartbeatTimer();
            }
            catch (Exception ex)
            {
                LogMessage(LogLevel.Error, $"Failed to connect to VRChat WebSocket: {ex.Message}", ex);
                throw;
            }
        }

        /// <inheritdoc/>
        public async Task DisconnectAsync()
        {
            _isManualDisconnect = true;
            
            // Stop timers
            _reconnectTimer?.Dispose();
            _reconnectTimer = null;
            _heartbeatTimer?.Dispose();
            _heartbeatTimer = null;

            // Cancel receiving
            _receiveCts?.Cancel();

            if (_client != null && _client.State == WebSocketState.Open)
            {
                try
                {
                    await _client.CloseAsync(WebSocketCloseStatus.NormalClosure, "Client disconnecting", CancellationToken.None);
                }
                catch (Exception ex)
                {
                    LogMessage(LogLevel.Warning, $"Error during disconnect: {ex.Message}", ex);
                }
            }

            _client?.Dispose();
            _client = null;

            if (_receiveTask != null)
            {
                try
                {
                    await _receiveTask;
                }
                catch (OperationCanceledException)
                {
                    // Expected
                }
                catch (Exception ex)
                {
                    LogMessage(LogLevel.Warning, $"Error waiting for receive task: {ex.Message}", ex);
                }
            }

            LogMessage(LogLevel.Info, "Disconnected from VRChat WebSocket");
        }

        private async Task ReceiveLoop(CancellationToken cancellationToken)
        {
            var buffer = new byte[8192];
            var messageBuffer = new StringBuilder();

            try
            {
                while (!cancellationToken.IsCancellationRequested && _client.State == WebSocketState.Open)
                {
                    WebSocketReceiveResult result;
                    messageBuffer.Clear();

                    do
                    {
                        result = await _client.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationToken);
                        
                        if (result.MessageType == WebSocketMessageType.Close)
                        {
                            await HandleDisconnection();
                            return;
                        }

                        messageBuffer.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                    }
                    while (!result.EndOfMessage);

                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        var message = messageBuffer.ToString();
                        HandleMessage(message);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // Expected when cancelling
            }
            catch (WebSocketException ex)
            {
                LogMessage(LogLevel.Error, $"WebSocket error: {ex.Message}", ex);
                await HandleDisconnection();
            }
            catch (Exception ex)
            {
                LogMessage(LogLevel.Error, $"Receive loop error: {ex.Message}", ex);
                await HandleDisconnection();
            }
        }

        private async Task SendHeartbeatAsync()
        {
            if (_client?.State != WebSocketState.Open)
                return;

            try
            {
                var heartbeat = new HeartbeatMessage
                {
                    Nonce = Guid.NewGuid().ToString()
                };

                var json = JsonSerializer.Serialize(heartbeat);
                var bytes = Encoding.UTF8.GetBytes(json);

                await _sendLock.WaitAsync();
                try
                {
                    await _client.SendAsync(
                        new ArraySegment<byte>(bytes),
                        WebSocketMessageType.Text,
                        true,
                        CancellationToken.None);

                    LogMessage(LogLevel.Trace, $"Heartbeat sent: {heartbeat.Nonce}");
                    OnHeartbeat?.Invoke(this, EventArgs.Empty);
                }
                finally
                {
                    _sendLock.Release();
                }
            }
            catch (Exception ex)
            {
                LogMessage(LogLevel.Warning, $"Failed to send heartbeat: {ex.Message}", ex);
            }
        }

        private void SetupReconnectTimer()
        {
            _reconnectTimer?.Dispose();

            TimeSpan? interval = _configuration.AutoReconnectMode switch
            {
                AutoReconnectMode.Every10Minutes => TimeSpan.FromMinutes(10),
                AutoReconnectMode.Every20Minutes => TimeSpan.FromMinutes(20),
                AutoReconnectMode.Every30Minutes => TimeSpan.FromMinutes(30),
                _ => null
            };

            if (interval.HasValue)
            {
                _reconnectTimer = new Timer(async _ =>
                {
                    try
                    {
                        OnAutoReconnecting?.Invoke(this, EventArgs.Empty);
                        LogMessage(LogLevel.Info, $"Auto-reconnecting (mode: {_configuration.AutoReconnectMode})");
                        
                        await DisconnectAsync();
                        await Task.Delay(150); // Brief delay before reconnecting
                        await ConnectAsync();
                    }
                    catch (Exception ex)
                    {
                        LogMessage(LogLevel.Error, $"Auto-reconnect failed: {ex.Message}", ex);
                    }
                }, null, interval.Value, interval.Value);
            }
        }

        private void SetupHeartbeatTimer()
        {
            _heartbeatTimer?.Dispose();

            _heartbeatTimer = new Timer(async _ =>
            {
                await SendHeartbeatAsync();
            }, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
        }

        private void HandleMessage(string json)
        {
            try
            {
                LogMessage(LogLevel.Trace, $"Received message: {json}");

                // Fire raw message received event
                OnMessageReceived?.Invoke(this, new VRChatEventArgs<string>
                {
                    Message = json,
                    RawMessage = json,
                    RawContent = null,
                    Type = "raw"
                });

                using var document = JsonDocument.Parse(json);
                var root = document.RootElement;

                if (!root.TryGetProperty("type", out var typeElement))
                {
                    LogMessage(LogLevel.Warning, "Received message without type field");
                    return;
                }

                var messageType = typeElement.GetString();
                if (string.IsNullOrWhiteSpace(messageType))
                {
                    LogMessage(LogLevel.Warning, "Received message with empty type");
                    return;
                }

                // Extract content once at the top level to avoid re-parsing JSON in processors
                string rawContent = null;
                if (root.TryGetProperty("content", out var contentElement))
                {
                    rawContent = contentElement.ValueKind == JsonValueKind.String
                        ? contentElement.GetString()
                        : contentElement.GetRawText();
                }

                ProcessMessage(messageType, json, rawContent);
            }
            catch (Exception ex)
            {
                LogMessage(LogLevel.Error, $"Error processing message: {ex.Message}", ex);
            }
        }

        private async Task HandleDisconnection()
        {
            LogMessage(LogLevel.Info, "WebSocket disconnected");
            OnDisconnected?.Invoke(this, EventArgs.Empty);

            if (!_isManualDisconnect && _configuration.AutoReconnectMode >= AutoReconnectMode.OnDisconnect)
            {
                await Task.Run(async () =>
                {
                    try
                    {
                        OnAutoReconnecting?.Invoke(this, EventArgs.Empty);
                        LogMessage(LogLevel.Info, "Attempting to reconnect...");
                        await Task.Delay(2000); // Wait 2 seconds before reconnecting
                        await ConnectAsync();
                    }
                    catch (Exception ex)
                    {
                        LogMessage(LogLevel.Error, $"Reconnection failed: {ex.Message}", ex);
                    }
                });
            }
        }

        private void LogMessage(LogLevel level, string message, Exception exception = null)
        {
            Log?.Invoke(this, new LogEventArgs
            {
                Level = level,
                Message = message,
                Exception = exception
            });
        }

        /// <summary>
        /// Releases all resources used by the <see cref="VRChatRealtimeClient"/>.
        /// </summary>
        /// <remarks>
        /// Call this method when you are done using the client to release WebSocket connections,
        /// timers, and other resources. After calling Dispose, the client cannot be reused.
        /// </remarks>
        public void Dispose()
        {
            if (!_disposed)
            {
                _reconnectTimer?.Dispose();
                _heartbeatTimer?.Dispose();
                _receiveCts?.Cancel();
                _receiveCts?.Dispose();
                _client?.Dispose();
                _sendLock?.Dispose();
                _disposed = true;
            }
        }
    }
}
